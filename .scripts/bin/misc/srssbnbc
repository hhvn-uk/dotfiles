#!/bin/sh
#
# SRSSBNBC - simple RSSBNB client
# Created by Hayden Hamilton
#
# haydenvh.com
# Copyright (c) 2020 Hayden Hamilton
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# This work is free. You can redistribute it and/or modify it under the      
# terms of the Do What The Fuck You Want To Public License, Version 2,       
# as published by Sam Hocevar. See http://www.wtfpl.net/ for more details.   


cache=${XDG_CACHE_HOME:=$HOME/.cache}
config=${XDG_CONFIG_HOME:=$HOME/.config}

[ "$1" = "-n" ] && grep -rnw $cache/srssbnbc/ -e 'Read[[:space:]]*:[[:space:]]*unread' | wc -l && exit
[ "$1" = "-h" ] && {
	echo "usage: [-h] [-n]

-n	count number of unread entries
-h	display this usage

files:
	$config/srssbnbc/feeds	one rssbnbc url on each line
	$config/srssbnbc/rss	first column is a url, second is a name for the feed
				columns are seperated with tab chars '\t'" && exit 1
}

parseconfig(){
	mkdir -p $config/srssbnbc
	[ ! -f $config/srssbnbc/feeds ] && {
		printf "No feed file!\nSyntax: url^1\n        url^2\n        ...\n        url^N\n"
		exit 1
	}
	while IFS= read -r line
	do
		f=$(mktemp)
		curl -qs $line > $f
		parsefile $f "$(echo "$line" | base32)" "$line"
		rm $f
	done < $config/srssbnbc/feeds
}

parserssconfig(){
	[ ! -f $config/srssbnbc/rss ] && return

	while IFS= read -r line
	do
		f=$(mktemp)
		curl ${line%%	*} > $f
		sfeed < $f | sed 's/:/\&#58;/g;s/,/\&#44;/g' | awk '
			BEGIN {
				FS="\t"
			}

			//{print ":sub,"$2","$3","$4":"}' | sed 's~\\t~\t~g;s~\\n~\n~g;s~\\\\~\\~g' | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'> $f
		parsefile $f "$(echo "${line##*	}" | base32 | head -n 1)" "${line%%	*}"
		printf  "Read  : Null\nTitle : %s\nLink  :\n\n" "${line##*	}" > $cache/srssbnbc/$(echo "${line##*	}" | base32 | head -n 1)/main.txt
		rm $f
	done < $config/srssbnbc/rss
}

parsefile(){
	# usage $1=file, $2=id, $3=name
	mkdir -p $cache/srssbnbc/$2 -p
	sed 's/\\:/\&#58;/g;s/\\,/\&#44;/g' < $1 | tr '\t\n:' '\f\t\n' | sed '/^[[:space:]]*$/d' | awk -v "cachedir=$cache/srssbnbc/$2" '
		BEGIN { 
			FS=","
			count="0"
		}

		$1 == "main" { 
			if (seenmain=="yes")
			 	exit 2
			seenmain="yes" 
			printf("Read  : Null\nTitle : %s\nLink  : %s\n\n%s\n\n", $2, $3, $4) > cachedir"/main.txt"
		}
		
		$1 != "main" {
			count++
			vcount=sprintf("%06d", count)
			if (system("test -f " cachedir"/"vcount".txt") != "0")
				printf("Read  : unread\nTitle : %s\nLink  : %s\n\n%s\n", $2, $3, $4) > cachedir"/"vcount".txt"
		}
	'

	[ "$?" = "2" ] && echo "Two 'main' items... quiting in feed $3" >/dev/stderr && return
}

_ui(){
	count=0
	dirs=$(ls $cache/srssbnbc/ | nl)
	IFS='
'
	while true
	do
		clear

		for d in $dirs
		do
			dir=$(echo "$d" | awk '{$1="";print $0}' | sed 's/[[:space:]]//g')
			num=$(echo "$d" | awk '{print $1}')
			name=$(grep 'Title[[:space:]]*:' < $cache/srssbnbc/$dir/main.txt | awk '{$1="";$2="";print $0}' | sed 's/^[[:space:]]*/ /')
			unread=$(grep -rnw $cache/srssbnbc/$dir -e 'Read[[:space:]]*:[[:space:]]*unread' | wc -l)
			[ $unread -gt 0 ] && echo "$num $name $(tput bold)*$unread UNREAD ENTRIES*$(tput sgr0)" || echo "$num $name"
		done | sed 's/&#58;/:/g;s/&#44;/,/g'

		printf '\n\nSelect a feed: '
		read feed < /dev/tty
		cd $cache/srssbnbc/$(echo "$dirs" | grep "^[[:space:]]*$feed[[:space:]]" | awk '{$1="";print $0}' | sed 's/[[:space:]]//g')

		while true
		do
			clear

			temp=$(mktemp)
			files=$(ls | nl | sed '/main\.txt/d')
			for f in $files
			do
				file=$(echo "$f" | awk '{$1="";print $0}' | sed 's/[[:space:]]//g')
				num=$(echo "$f" | awk '{print $1}')
				name=$(grep 'Title[[:space:]]*:' < $file | awk '{$1="";$2="";print $0}' | sed 's/^[[:space:]]*/ /')
				grep 'Read[[:space:]]*:[[:space:]]*unread' < $file >/dev/null && echo "$num $name $(tput bold)*UNREAD*$(tput sgr0)" || echo "$num $name"
			done > $temp
			tail -n 20 < $temp | cat main.txt /dev/stdin | sed 's/&#58;/:/g;s/&#44;/,/g'
			printf "\n\nSelect an item, 'list' - list all entries, 'q' - go back, 'a' - mark all as read: "
			read choice < /dev/tty
			[ "$choice" = "list" ] && less $temp && printf "\n\nSelect an item: " && read choice < /dev/tty
			[ "$choice" = "q" ] && break
			[ "$choice" = "a" ] && {
				for f in $(find -type f); do out=$(sed '/^Read[[:space:]]*:[[:space:]]*unread/d' < $f); echo "$out" > $f; done
				continue
			}
			fchoice=$(echo "$files" | grep "^[[:space:]]*$choice[[:space:]]*" | awk '{$1="";print $0}' | sed 's/[[:space:]]//g')
			[ -f $fchoice ] && {
				tr '\f\t' '\t\n' < $fchoice | sed 's/&#58;/:/g;s/&#44;/,/g' | less
				out=$(sed '/^Read[[:space:]]*:[[:space:]]*unread/d' < $fchoice)
				echo "$out" > $fchoice
			} || echo 'entry does not exist'
			rm $temp
		done
	done
}


parseconfig
parserssconfig
_ui
